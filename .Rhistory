# Load required library
library(pheatmap)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure the group_vector is a factor with correct levels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
mat_col <- data.frame(Sample = group_vector)
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- levels(group_vector)
if (is.null(annotation_col)) {
# Generate default colors if not provided
default_colors <- colorRampPalette(c("darkgreen", "darkred"))(length(unique_groups))
annotation_col <- list(Sample = setNames(default_colors, unique_groups))
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col$Sample) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the unique values in 'group_vector'.")
}
# Ensure that names of colors match unique group names
names(annotation_col$Sample) <- unique_groups
}
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = mat_col,
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df_ICR, group_vector = group_vector,  cluster_by = "cord" )
df_ICR
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" )
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" )
#' Generate Heatmap of Imprinted DMRs Methylation
#'
#' This function generates a heatmap for visualizing methylation data of Imprinted Differentially Methylated Regions (DMRs).
#' It allows custom color schemes for group annotations, with default colors from the "viridis" palette.
#'
#' @param df_ICR A data frame or matrix containing methylation beta values for Imprinted DMRs.
#' @param group_vector A vector indicating the group labels (e.g., "Control" and "Case") for each sample in `df_ICR`.
#' @param control_label A character string specifying the label for the control group in `group_vector`. Default is `"Control"`.
#' @param case_label A character string specifying the label for the case group in `group_vector`. Default is `"Case"`.
#' @param bedmeth A character string specifying the BED data version for DMR coordinates. Options are `"v1"`, `"v2"`, or `"450k"`. Default is `"v1"`.
#' @param cluster_by A character string specifying the clustering method for rows in the heatmap. Options are `"cord"` or `"meth"`. Default is `"cord"`.
#' @param annotation_col A named list of colors for each unique value in `group_vector`. If `NULL`, default colors are assigned using the "viridis" palette. Default is `NULL`.
#' @return A heatmap plot visualizing methylation of Imprinted DMRs.
#' @examples
#' DMR_heatmap(df_ICR = my_ICR_data, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
#' @export
DMR_heatmap <- function(df_ICR, group_vector, control_label = "Control", case_label = "Case", bedmeth = "v1", cluster_by = "cord", annotation_col = NULL) {
# Load required libraries
library(pheatmap)
library(viridisLite)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure the group_vector is a factor with correct levels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
mat_col <- data.frame(Sample = group_vector)
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- levels(group_vector)
if (is.null(annotation_col)) {
# Generate default colors using the viridis palette if not provided
default_colors <- viridisLite::viridis(length(unique_groups))
annotation_col <- list(Sample = setNames(default_colors, unique_groups))
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col$Sample) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the unique values in 'group_vector'.")
}
# Ensure that names of colors match unique group names
names(annotation_col$Sample) <- unique_groups
}
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = mat_col,
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" )
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = c("pink", "blue","red"))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = c("blue","red"))
group_vector
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = c("blue","red"))
levels(group_vector)
#' Generate Heatmap of Imprinted DMRs Methylation
#'
#' This function generates a heatmap for visualizing methylation data of Imprinted Differentially Methylated Regions (DMRs).
#' It allows custom color schemes for group annotations, with default colors from the "viridis" palette.
#'
#' @param df_ICR A data frame or matrix containing methylation beta values for Imprinted DMRs.
#' @param group_vector A vector indicating the group labels (e.g., "Control" and "Case") for each sample in `df_ICR`.
#' @param control_label A character string specifying the label for the control group in `group_vector`. Default is `"Control"`.
#' @param case_label A character string specifying the label for the case group in `group_vector`. Default is `"Case"`.
#' @param bedmeth A character string specifying the BED data version for DMR coordinates. Options are `"v1"`, `"v2"`, or `"450k"`. Default is `"v1"`.
#' @param cluster_by A character string specifying the clustering method for rows in the heatmap. Options are `"cord"` or `"meth"`. Default is `"cord"`.
#' @param annotation_col A named list of colors for each unique value in `group_vector`. If `NULL`, default colors are assigned using the "viridis" palette. Default is `NULL`.
#' @return A heatmap plot visualizing methylation of Imprinted DMRs.
#' @examples
#' DMR_heatmap(df_ICR = my_ICR_data, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
#' @export
DMR_heatmap <- function(df_ICR, group_vector, control_label = "Control", case_label = "Case", bedmeth = "v1", cluster_by = "cord", annotation_col = NULL) {
# Load required libraries
library(pheatmap)
library(viridisLite)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure the group_vector is a factor with correct levels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
mat_col <- data.frame(Sample = group_vector)
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- unique(group_vector)
if (is.null(annotation_col)) {
# Generate default colors using the viridis palette if not provided
default_colors <- viridisLite::viridis(length(unique_groups))
annotation_col <- list(Sample = setNames(default_colors, unique_groups))
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col$Sample) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the levels in 'group_vector'.")
}
# Ensure that names of colors match unique group names
names(annotation_col$Sample) <- unique_groups
}
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = mat_col,
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = c("blue","red"))
unique(group_vector)
#' Generate Heatmap of Imprinted DMRs Methylation
#'
#' This function generates a heatmap for visualizing methylation data of Imprinted Differentially Methylated Regions (DMRs).
#' It allows custom color schemes for group annotations, with default colors from the "viridis" palette.
#'
#' @param df_ICR A data frame or matrix containing methylation beta values for Imprinted DMRs.
#' @param group_vector A vector indicating the group labels (e.g., "Control" and "Case") for each sample in `df_ICR`.
#' @param control_label A character string specifying the label for the control group in `group_vector`. Default is `"Control"`.
#' @param case_label A character string specifying the label for the case group in `group_vector`. Default is `"Case"`.
#' @param bedmeth A character string specifying the BED data version for DMR coordinates. Options are `"v1"`, `"v2"`, or `"450k"`. Default is `"v1"`.
#' @param cluster_by A character string specifying the clustering method for rows in the heatmap. Options are `"cord"` or `"meth"`. Default is `"cord"`.
#' @param annotation_col A named list of colors for each unique value in `group_vector`. If `NULL`, default colors are assigned using the "viridis" palette. Default is `NULL`.
#' @return A heatmap plot visualizing methylation of Imprinted DMRs.
#' @examples
#' DMR_heatmap(df_ICR = my_ICR_data, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
#' @export
DMR_heatmap <- function(df_ICR, group_vector, control_label = "Control", case_label = "Case", bedmeth = "v1", cluster_by = "cord", annotation_col = NULL) {
# Load required libraries
library(pheatmap)
library(viridisLite)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure the group_vector is a factor with correct levels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
mat_col <- data.frame(Sample = group_vector)
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- unique(group_vector)
if (is.null(annotation_col)) {
# Generate default colors using the viridis palette if not provided
default_colors <- viridisLite::viridis(length(unique_groups))
annotation_col <- list(Sample = setNames(default_colors, unique_groups))
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col$Sample) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the levels in 'group_vector'.", length(annotation_col$Sample),  length(unique_groups))
}
# Ensure that names of colors match unique group names
names(annotation_col$Sample) <- unique_groups
}
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = mat_col,
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = c("blue","red"))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" )
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Sample = c("darkgreen", "darkred")))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Pimple = c("darkgreen", "darkred")))
#' Generate Heatmap of Imprinted DMRs Methylation
#'
#' This function generates a heatmap for visualizing methylation data of Imprinted Differentially Methylated Regions (DMRs).
#' It allows custom color schemes for group annotations, with default colors from the "viridis" palette.
#'
#' @param df_ICR A data frame or matrix containing methylation beta values for Imprinted DMRs.
#' @param group_vector A vector indicating the group labels (e.g., "Control" and "Case") for each sample in `df_ICR`.
#' @param control_label A character string specifying the label for the control group in `group_vector`. Default is `"Control"`.
#' @param case_label A character string specifying the label for the case group in `group_vector`. Default is `"Case"`.
#' @param bedmeth A character string specifying the BED data version for DMR coordinates. Options are `"v1"`, `"v2"`, or `"450k"`. Default is `"v1"`.
#' @param cluster_by A character string specifying the clustering method for rows in the heatmap. Options are `"cord"` or `"meth"`. Default is `"cord"`.
#' @param annotation_col A named list of colors for each unique value in `group_vector`. If `NULL`, default colors are assigned using the "viridis" palette. Default is `NULL`.
#' @return A heatmap plot visualizing methylation of Imprinted DMRs.
#' @examples
#' DMR_heatmap(df_ICR = my_ICR_data, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
#' @export
DMR_heatmap <- function(df_ICR, group_vector, control_label = "Control", case_label = "Case", bedmeth = "v1", cluster_by = "cord", annotation_col = NULL) {
# Load required libraries
library(pheatmap)
library(viridisLite)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure the group_vector is a factor with correct levels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
mat_col <- data.frame(Sample = group_vector)
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- unique(group_vector)
if (is.null(annotation_col)) {
# Generate default colors using the viridis palette if not provided
default_colors <- viridisLite::viridis(length(unique_groups))
annotation_col <- list(Sample = setNames(default_colors, unique_groups))
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col[[1]]) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the unique values in 'group_vector'.")
}
# Dynamically set the names of colors to match unique group names
names(annotation_col[[1]]) <- unique_groups
}
# Extract the name of the first element in annotation_col for legend title
annotation_name <- names(annotation_col)[1]
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = setNames(list(mat_col), annotation_name),
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Pimple = c("darkgreen", "darkred")))
DMR_heatmap(df_ICR = my_ICR_data, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
DMR_heatmap(df_ICR = df.ICR, group_vector , annotation_col = list(Sample = c("darkgreen", "darkred")))
DMR_heatmap(df_ICR = df.ICR, group_vector = c("Control", "Case"), annotation_col = list(Sample = c("darkgreen", "darkred")))
DMR_heatmap(df_ICR = df.ICR, group_vector, annotation_col = list(Sample = c("darkgreen", "darkred")))
group_vector
#' Generate Heatmap of Imprinted DMRs Methylation
#'
#' This function generates a heatmap for visualizing methylation data of Imprinted Differentially Methylated Regions (DMRs).
#' It allows custom color schemes for group annotations, with default colors from the "viridis" palette.
#'
#' @param df_ICR A data frame or matrix containing methylation beta values for Imprinted DMRs.
#' @param group_vector A vector indicating the group labels (e.g., "Control" and "Case") for each sample in `df_ICR`.
#' Each element in `group_vector` should correspond to a sample in `df_ICR`.
#' @param control_label A character string specifying the label for the control group in `group_vector`. Default is `"Control"`.
#' @param case_label A character string specifying the label for the case group in `group_vector`. Default is `"Case"`.
#' @param bedmeth A character string specifying the BED data version for DMR coordinates. Options are `"v1"`, `"v2"`, or `"450k"`. Default is `"v1"`.
#' @param cluster_by A character string specifying the clustering method for rows in the heatmap. Options are `"cord"` or `"meth"`. Default is `"cord"`.
#' @param annotation_col A named list of colors for each unique value in `group_vector`. If `NULL`, default colors are assigned using the "viridis" palette. Default is `NULL`.
#' @return A heatmap plot visualizing methylation of Imprinted DMRs.
#' @examples
#' # Example group_vector with "Case" and "Control" labels for each sample
#' group_vector <- c(rep("Case", 10), rep("Control", 10))
#' DMR_heatmap(df_ICR = my_ICR_data, group_vector = group_vector, annotation_col = list(Sample = c("darkgreen", "darkred")))
#' @export
DMR_heatmap <- function(df_ICR, group_vector, control_label = "Control", case_label = "Case", bedmeth = "v1", cluster_by = "cord", annotation_col = NULL) {
# Load required libraries
library(pheatmap)
library(viridisLite)
# Load BED data based on bedmeth version
if (bedmeth == "v1" || bedmeth == "450k") {
data(DMRs.hg19)
ICR_cord <- DMRs.hg19
odr <- ICR_cord$ICR
} else if (bedmeth == "v2") {
data(DMRs.hg38)
ICR_cord <- DMRs.hg38
odr <- ICR_cord$ICR
} else {
stop("Invalid bedmeth version. Choose from 'v1', 'v2', or '450k'.")
}
# Ensure that group_vector has the same length as the number of samples (columns) in df_ICR
if (length(group_vector) != ncol(df_ICR)) {
stop("Length of 'group_vector' must match the number of samples (columns) in 'df_ICR'.")
}
# Convert group_vector to a factor with specified control and case labels
group_vector <- factor(group_vector, levels = c(control_label, case_label))
# Extract the name for annotation title
annotation_name <- if (!is.null(annotation_col)) names(annotation_col)[1] else "Sample"
# Create the annotation data frame using group_vector with the extracted name as the column title
mat_col <- data.frame(group_vector)
colnames(mat_col) <- annotation_name
rownames(mat_col) <- colnames(df_ICR)
# Generate or validate annotation colors
unique_groups <- levels(group_vector)
if (is.null(annotation_col)) {
# Generate default colors using the viridis palette if not provided
default_colors <- viridisLite::viridis(length(unique_groups))
annotation_col <- list(setNames(default_colors, unique_groups))
names(annotation_col) <- annotation_name
} else {
# Validate that the number of colors matches the number of unique groups
if (!is.list(annotation_col) || length(annotation_col[[1]]) != length(unique_groups)) {
stop("The 'annotation_col' list must have the same number of colors as the unique values in 'group_vector'.")
}
# Ensure that names of colors match unique group names
names(annotation_col[[1]]) <- unique_groups
}
# Define heatmap colors and breaks
paletteLength <- 100
myColor <- colorRampPalette(c("#785EF0", "white", "#9a031e"))(paletteLength)
myBreaks <- c(seq(0, 0.5, length.out = ceiling(paletteLength / 2) + 1),
seq(0.500001, 1, length.out = floor(paletteLength / 2)))
# Determine row clustering based on cluster_by parameter
row_clust <- if (cluster_by == "cord") FALSE else if (cluster_by == "meth") TRUE else {
stop("Please select a valid 'cluster_by' parameter: 'cord' to cluster by coordinates or 'meth' to cluster by methylation values.")
}
# Generate the heatmap
pheatmap(
mat = df_ICR[odr, ],
annotation_col = mat_col,
annotation_colors = annotation_col,
color = myColor,
breaks = myBreaks,
border_color = "grey",
main = "Methylation of Imprinted DMRs",
annotation_legend = TRUE,
annotation_names_col = FALSE,
annotation_names_row = FALSE,
drop_levels = FALSE,
fontsize = 8,
cluster_rows = row_clust,
cluster_cols = TRUE,
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "ward.D2"
)
}
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Pimple = c("darkgreen", "darkred")))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Sala = c("darkgreen", "darkred")))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col = list(Sala = c("darkgreen", "darkred", "pink")))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" ))
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" )
library(roxygen2)
roxygenize()
setwd("/run/media/saadat/A/GIMP/GIMP")
setwd("/run/media/saadat/A/GIMP/GIMP")
roxygenize()
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col =  list(Sample = c("pink", "darkred")) )
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col =  list(Tatty = c("pink", "darkred")) )
?DMR_heatmap
DMR_heatmap(df.ICR, group_vector = group_vector,  cluster_by = "cord" , annotation_col =  list(Sample = c("pink", "darkred")) )
